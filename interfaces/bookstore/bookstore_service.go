// Code generated by service_generator. DO NOT EDIT.
package bookstore

import (
	"context"
	"os"

	"saastack/core" // Assuming this is a common core package for your project
	// The protobuf import path is now constructed dynamically based on GeneratedPackageName.
	pb "saastack/interfaces/bookstore/proto"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"github.com/joho/godotenv"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// BookstoreServiceInterface defines the interface for the bookstore service.
// It embeds the gRPC server interface generated from the proto definition.
type BookstoreServiceInterface interface {
	pb.BookstoreServiceServer
}

// PluginRegistry defines the interface for a plugin management system.
// This is a common interface assumed to be used by services for dynamic plugin loading.
type PluginRegistry interface {
	GetPlugin(interfaceName, pluginName string) (interface{}, bool)
}

// BookstoreService implements the BookstoreServiceServer interface generated from the proto definition.
// It handles gRPC requests and delegates them to registered plugins.
type BookstoreService struct {
	pb.UnimplementedBookstoreServiceServer
	registry PluginRegistry // The plugin registry used to fetch specific plugin implementations.
}

// NewBookstoreService creates a new instance of BookstoreService.
// It requires a PluginRegistry to operate.
func NewBookstoreService(registry PluginRegistry) *BookstoreService {
	return &BookstoreService{
		registry: registry,
	}
}

// init registers this service with a global registry (assumed to be core.GlobalRegistry).
// This allows the service to be discovered and used by the application.
// The service is registered with its derived PluginKey.
func init() {
	// Create a new service instance, using the global plugin registry.
	service := NewBookstoreService(core.GlobalRegistry)
	// Register the service with the global service registry using its PluginKey.
	core.GlobalRegistry.RegisterService("bookstore", service)
}

// RegisterGRPC registers the gRPC service with a gRPC server.
func (s *BookstoreService) RegisterGRPC(server *grpc.Server) {
	pb.RegisterBookstoreServiceServer(server, s)
}

// RegisterHTTP registers the HTTP gateway handler for the service.
// This allows the service to be exposed over HTTP via grpc-gateway.
func (s *BookstoreService) RegisterHTTP(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) error {
	return pb.RegisterBookstoreServiceHandlerFromEndpoint(ctx, mux, endpoint, opts)
}


// AddBook handles the AddBook gRPC request.
// It determines the appropriate plugin and delegates the call.
func (s *BookstoreService) AddBook(ctx context.Context, req *pb.AddBookRequest) (*pb.GenericResponse, error) {
	// Attempt to load environment variables from a .env file.
	_ = godotenv.Load(".env") // Ignoring error for flexibility

	// Determine the plugin name.
	// The default plugin name is read from an environment variable derived from the PluginKey
	// (e.g., NOTIFICATION_PLUGIN, BOOKSTORE_PLUGIN).
	envVarName := "BOOKSTORE_PLUGIN"
	pluginName := os.Getenv(envVarName)

	// If the request message has a 'Plugin' field, its value can override the default plugin name.
	// This directly follows the user's example: if req.Plugin != ""
	// WARNING: If 'pb.AddBookRequest' does not have a 'Plugin string' field, this will NOT COMPILE.
	// Ensure your .proto messages define 'string plugin = N;' for relevant request types.
	if req.Plugin != "" {
		pluginName = req.Plugin
	}

	// Retrieve the plugin implementation from the registry.
	// The interfaceName argument to GetPlugin is the service's PluginKey (e.g., "notification", "bookstore").
	pluginInstance, ok := s.registry.GetPlugin("bookstore", pluginName)
	if !ok {
		return nil, status.Errorf(codes.Unimplemented, "plugin '%s' for interface '%s' not found", pluginName, "bookstore")
	}

	// Assert that the retrieved plugin implements the required service-specific interface
	// (e.g., BookstoreServiceInterface, which embeds pb.BookstoreServiceServer).
	servicePlugin, ok := pluginInstance.(BookstoreServiceInterface)
	if !ok {
		return nil, status.Errorf(codes.Internal, "plugin '%s' does not implement required interface BookstoreServiceInterface (for 'bookstore' plugin type)", pluginName)
	}

	// Delegate the actual RPC call to the corresponding method on the resolved plugin.
	return servicePlugin.AddBook(ctx, req)
}

// GetBook handles the GetBook gRPC request.
// It determines the appropriate plugin and delegates the call.
func (s *BookstoreService) GetBook(ctx context.Context, req *pb.GetBookRequest) (*pb.GenericResponse, error) {
	// Attempt to load environment variables from a .env file.
	_ = godotenv.Load(".env") // Ignoring error for flexibility

	// Determine the plugin name.
	// The default plugin name is read from an environment variable derived from the PluginKey
	// (e.g., NOTIFICATION_PLUGIN, BOOKSTORE_PLUGIN).
	envVarName := "BOOKSTORE_PLUGIN"
	pluginName := os.Getenv(envVarName)

	// If the request message has a 'Plugin' field, its value can override the default plugin name.
	// This directly follows the user's example: if req.Plugin != ""
	// WARNING: If 'pb.GetBookRequest' does not have a 'Plugin string' field, this will NOT COMPILE.
	// Ensure your .proto messages define 'string plugin = N;' for relevant request types.
	if req.Plugin != "" {
		pluginName = req.Plugin
	}

	// Retrieve the plugin implementation from the registry.
	// The interfaceName argument to GetPlugin is the service's PluginKey (e.g., "notification", "bookstore").
	pluginInstance, ok := s.registry.GetPlugin("bookstore", pluginName)
	if !ok {
		return nil, status.Errorf(codes.Unimplemented, "plugin '%s' for interface '%s' not found", pluginName, "bookstore")
	}

	// Assert that the retrieved plugin implements the required service-specific interface
	// (e.g., BookstoreServiceInterface, which embeds pb.BookstoreServiceServer).
	servicePlugin, ok := pluginInstance.(BookstoreServiceInterface)
	if !ok {
		return nil, status.Errorf(codes.Internal, "plugin '%s' does not implement required interface BookstoreServiceInterface (for 'bookstore' plugin type)", pluginName)
	}

	// Delegate the actual RPC call to the corresponding method on the resolved plugin.
	return servicePlugin.GetBook(ctx, req)
}

// ListBooks handles the ListBooks gRPC request.
// It determines the appropriate plugin and delegates the call.
func (s *BookstoreService) ListBooks(ctx context.Context, req *pb.ListBooksRequest) (*pb.ListBooksResponse, error) {
	// Attempt to load environment variables from a .env file.
	_ = godotenv.Load(".env") // Ignoring error for flexibility

	// Determine the plugin name.
	// The default plugin name is read from an environment variable derived from the PluginKey
	// (e.g., NOTIFICATION_PLUGIN, BOOKSTORE_PLUGIN).
	envVarName := "BOOKSTORE_PLUGIN"
	pluginName := os.Getenv(envVarName)

	// If the request message has a 'Plugin' field, its value can override the default plugin name.
	// This directly follows the user's example: if req.Plugin != ""
	// WARNING: If 'pb.ListBooksRequest' does not have a 'Plugin string' field, this will NOT COMPILE.
	// Ensure your .proto messages define 'string plugin = N;' for relevant request types.
	if req.Plugin != "" {
		pluginName = req.Plugin
	}

	// Retrieve the plugin implementation from the registry.
	// The interfaceName argument to GetPlugin is the service's PluginKey (e.g., "notification", "bookstore").
	pluginInstance, ok := s.registry.GetPlugin("bookstore", pluginName)
	if !ok {
		return nil, status.Errorf(codes.Unimplemented, "plugin '%s' for interface '%s' not found", pluginName, "bookstore")
	}

	// Assert that the retrieved plugin implements the required service-specific interface
	// (e.g., BookstoreServiceInterface, which embeds pb.BookstoreServiceServer).
	servicePlugin, ok := pluginInstance.(BookstoreServiceInterface)
	if !ok {
		return nil, status.Errorf(codes.Internal, "plugin '%s' does not implement required interface BookstoreServiceInterface (for 'bookstore' plugin type)", pluginName)
	}

	// Delegate the actual RPC call to the corresponding method on the resolved plugin.
	return servicePlugin.ListBooks(ctx, req)
}

// DeleteBook handles the DeleteBook gRPC request.
// It determines the appropriate plugin and delegates the call.
func (s *BookstoreService) DeleteBook(ctx context.Context, req *pb.DeleteBookRequest) (*pb.GenericResponse, error) {
	// Attempt to load environment variables from a .env file.
	_ = godotenv.Load(".env") // Ignoring error for flexibility

	// Determine the plugin name.
	// The default plugin name is read from an environment variable derived from the PluginKey
	// (e.g., NOTIFICATION_PLUGIN, BOOKSTORE_PLUGIN).
	envVarName := "BOOKSTORE_PLUGIN"
	pluginName := os.Getenv(envVarName)

	// If the request message has a 'Plugin' field, its value can override the default plugin name.
	// This directly follows the user's example: if req.Plugin != ""
	// WARNING: If 'pb.DeleteBookRequest' does not have a 'Plugin string' field, this will NOT COMPILE.
	// Ensure your .proto messages define 'string plugin = N;' for relevant request types.
	if req.Plugin != "" {
		pluginName = req.Plugin
	}

	// Retrieve the plugin implementation from the registry.
	// The interfaceName argument to GetPlugin is the service's PluginKey (e.g., "notification", "bookstore").
	pluginInstance, ok := s.registry.GetPlugin("bookstore", pluginName)
	if !ok {
		return nil, status.Errorf(codes.Unimplemented, "plugin '%s' for interface '%s' not found", pluginName, "bookstore")
	}

	// Assert that the retrieved plugin implements the required service-specific interface
	// (e.g., BookstoreServiceInterface, which embeds pb.BookstoreServiceServer).
	servicePlugin, ok := pluginInstance.(BookstoreServiceInterface)
	if !ok {
		return nil, status.Errorf(codes.Internal, "plugin '%s' does not implement required interface BookstoreServiceInterface (for 'bookstore' plugin type)", pluginName)
	}

	// Delegate the actual RPC call to the corresponding method on the resolved plugin.
	return servicePlugin.DeleteBook(ctx, req)
}

