package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

// ServiceInfo holds all the parsed and derived information needed for templating.
type ServiceInfo struct {
	ProtoFilename        string    // Original .proto filename
	GoPackageImport      string    // Import path for pb, from go_package option (still parsed, but not directly used for the main pb import)
	GeneratedPackageName string    // Go package name for the generated _service.go file AND used in the custom proto path (e.g., "notification", "bookstore")
	ServiceName          string    // e.g., "NotificationService", "BookstoreService"
	PluginKey            string    // Derived from ServiceName, e.g., "notification", "bookstore". Used for env var and registry.
	RPCs                 []RPCInfo // List of RPC methods
}

// RPCInfo holds information about a single RPC method.
type RPCInfo struct {
	Name         string // e.g., "Send"
	RequestType  string // e.g., "SendRequest"
	ResponseType string // e.g., "SendResponse"
}

// Template for the _service.go file, corrected to use dynamic plugin keys
// and the exact req.Plugin access pattern.
const serviceTemplate = `// Code generated by service_generator. DO NOT EDIT.
package {{.GeneratedPackageName}}

import (
	"context"
	"os"

	"saastack/core" // Assuming this is a common core package for your project
	// The protobuf import path is now constructed dynamically based on GeneratedPackageName.
	pb "saastack/interfaces/{{.GeneratedPackageName}}/proto"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"github.com/joho/godotenv"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// {{.ServiceName}}Interface defines the interface for the {{.GeneratedPackageName}} service.
// It embeds the gRPC server interface generated from the proto definition.
type {{.ServiceName}}Interface interface {
	pb.{{.ServiceName}}Server
}

// PluginRegistry defines the interface for a plugin management system.
// This is a common interface assumed to be used by services for dynamic plugin loading.
type PluginRegistry interface {
	GetPlugin(interfaceName, pluginName string) (interface{}, bool)
}

// {{.ServiceName}} implements the {{.ServiceName}}Server interface generated from the proto definition.
// It handles gRPC requests and delegates them to registered plugins.
type {{.ServiceName}} struct {
	pb.Unimplemented{{.ServiceName}}Server
	registry PluginRegistry // The plugin registry used to fetch specific plugin implementations.
}

// New{{.ServiceName}} creates a new instance of {{.ServiceName}}.
// It requires a PluginRegistry to operate.
func New{{.ServiceName}}(registry PluginRegistry) *{{.ServiceName}} {
	return &{{.ServiceName}}{
		registry: registry,
	}
}

// init registers this service with a global registry (assumed to be core.GlobalRegistry).
// This allows the service to be discovered and used by the application.
// The service is registered with its derived PluginKey.
func init() {
	// Create a new service instance, using the global plugin registry.
	service := New{{.ServiceName}}(core.GlobalRegistry)
	// Register the service with the global service registry using its PluginKey.
	core.GlobalRegistry.RegisterService("{{.PluginKey}}", service)
}

// RegisterGRPC registers the gRPC service with a gRPC server.
func (s *{{.ServiceName}}) RegisterGRPC(server *grpc.Server) {
	pb.Register{{.ServiceName}}Server(server, s)
}

// RegisterHTTP registers the HTTP gateway handler for the service.
// This allows the service to be exposed over HTTP via grpc-gateway.
func (s *{{.ServiceName}}) RegisterHTTP(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) error {
	return pb.Register{{.ServiceName}}HandlerFromEndpoint(ctx, mux, endpoint, opts)
}

{{range .RPCs}}
// {{.Name}} handles the {{.Name}} gRPC request.
// It determines the appropriate plugin and delegates the call.
func (s *{{$.ServiceName}}) {{.Name}}(ctx context.Context, req *pb.{{.RequestType}}) (*pb.{{.ResponseType}}, error) {
	// Attempt to load environment variables from a .env file.
	_ = godotenv.Load(".env") // Ignoring error for flexibility

	// Determine the plugin name.
	// The default plugin name is read from an environment variable derived from the PluginKey
	// (e.g., NOTIFICATION_PLUGIN, BOOKSTORE_PLUGIN).
	envVarName := "{{ToUpper $.PluginKey}}_PLUGIN"
	pluginName := os.Getenv(envVarName)

	// If the request message has a 'Plugin' field, its value can override the default plugin name.
	// This directly follows the user's example: if req.Plugin != ""
	// WARNING: If 'pb.{{.RequestType}}' does not have a 'Plugin string' field, this will NOT COMPILE.
	// Ensure your .proto messages define 'string plugin = N;' for relevant request types.
	if req.Plugin != "" {
		pluginName = req.Plugin
	}

	// Retrieve the plugin implementation from the registry.
	// The interfaceName argument to GetPlugin is the service's PluginKey (e.g., "notification", "bookstore").
	pluginInstance, ok := s.registry.GetPlugin("{{$.PluginKey}}", pluginName)
	if !ok {
		return nil, status.Errorf(codes.Unimplemented, "plugin '%s' for interface '%s' not found", pluginName, "{{$.PluginKey}}")
	}

	// Assert that the retrieved plugin implements the required service-specific interface
	// (e.g., {{$.ServiceName}}Interface, which embeds pb.{{$.ServiceName}}Server).
	servicePlugin, ok := pluginInstance.({{- $.ServiceName -}}Interface)
	if !ok {
		return nil, status.Errorf(codes.Internal, "plugin '%s' does not implement required interface {{$.ServiceName}}Interface (for '{{$.PluginKey}}' plugin type)", pluginName)
	}

	// Delegate the actual RPC call to the corresponding method on the resolved plugin.
	return servicePlugin.{{.Name}}(ctx, req)
}
{{end}}
`

// derivePluginKeyAndPackageName derives the plugin key and package name from the service name.
// Example: "NotificationService" -> "notification"
// Example: "BookstoreService" -> "bookstore"
func derivePluginKeyAndPackageName(serviceName string) string {
	if strings.HasSuffix(serviceName, "Service") {
		return strings.ToLower(strings.TrimSuffix(serviceName, "Service"))
	}
	return strings.ToLower(serviceName)
}

func main() {
	protoFilePath := flag.String("proto", "", "Path to the .proto file")
	outputDir := flag.String("outdir", ".", "Output directory for the generated service file")
	flag.Parse()

	if *protoFilePath == "" {
		log.Fatal("Error: -proto flag is required. Usage: go run generator.go -proto <path_to_proto_file>")
	}

	protoContent, err := ioutil.ReadFile(*protoFilePath)
	if err != nil {
		log.Fatalf("Error reading .proto file %s: %v", *protoFilePath, err)
	}
	contentStr := string(protoContent)

	goPackageRegex := regexp.MustCompile(`option\s+go_package\s*=\s*"([^;"]+)(?:;[^"]+)?"\s*;`)
	serviceRegex := regexp.MustCompile(`service\s+(\w+)\s*{`)
	rpcRegex := regexp.MustCompile(`rpc\s+(\w+)\s*\(\s*(\w+)\s*\)\s*returns\s*\(\s*(\w+)\s*\)`)

	goPackageMatch := goPackageRegex.FindStringSubmatch(contentStr)
	var goPackageImportValue string
	if goPackageMatch != nil {
		goPackageImportValue = goPackageMatch[1]
	} else {
		log.Printf("Warning: 'option go_package' not found in %s. This option is typically used by protoc.", *protoFilePath)
		goPackageImportValue = ""
	}

	serviceMatch := serviceRegex.FindStringSubmatch(contentStr)
	if serviceMatch == nil {
		log.Fatalf("Error: No service definition found in %s.", *protoFilePath)
	}
	serviceName := serviceMatch[1]

	var rpcs []RPCInfo
	serviceBlockStart := strings.Index(contentStr, serviceMatch[0])
	if serviceBlockStart == -1 {
		log.Fatalf("Error finding service block for %s", serviceName)
	}
	serviceBlockEndSearchArea := contentStr[serviceBlockStart:]
	closingBraceIndex := -1
	openBraceCount := 0
	for i, char := range serviceBlockEndSearchArea {
		if char == '{' {
			openBraceCount++
		} else if char == '}' {
			openBraceCount--
			if openBraceCount == 0 {
				closingBraceIndex = i
				break
			}
		}
	}
	if closingBraceIndex == -1 {
		log.Fatalf("Error: Could not find closing brace for service %s.", serviceName)
	}

	serviceBlock := serviceBlockEndSearchArea[:closingBraceIndex+1]
	rpcMatches := rpcRegex.FindAllStringSubmatch(serviceBlock, -1)
	if rpcMatches == nil {
		log.Printf("Warning: No RPC methods found for service %s in %s.", serviceName, *protoFilePath)
	}

	for _, rpcMatch := range rpcMatches {
		rpcs = append(rpcs, RPCInfo{
			Name:         rpcMatch[1],
			RequestType:  rpcMatch[2],
			ResponseType: rpcMatch[3],
		})
	}

	// Derive the plugin key and package name (they are the same in this context)
	derivedName := derivePluginKeyAndPackageName(serviceName)

	serviceInfo := ServiceInfo{
		ProtoFilename:        filepath.Base(*protoFilePath),
		GoPackageImport:      goPackageImportValue,
		GeneratedPackageName: derivedName, // Used for package name and proto import path segment
		ServiceName:          serviceName,
		PluginKey:            derivedName, // Used for env var, registry key
		RPCs:                 rpcs,
	}

	funcMap := template.FuncMap{
		"ToUpper": strings.ToUpper,
	}

	tmpl, err := template.New("service").Funcs(funcMap).Parse(serviceTemplate)
	if err != nil {
		log.Fatalf("Error parsing service template: %v", err)
	}

	if _, err := os.Stat(*outputDir); os.IsNotExist(err) {
		if mkErr := os.MkdirAll(*outputDir, 0755); mkErr != nil {
			log.Fatalf("Error creating output directory %s: %v", *outputDir, mkErr)
		}
	}

	outputFileName := filepath.Join(*outputDir, derivedName+"_service.go")
	outputFile, err := os.Create(outputFileName)
	if err != nil {
		log.Fatalf("Error creating output file %s: %v", outputFileName, err)
	}
	defer outputFile.Close()

	err = tmpl.Execute(outputFile, serviceInfo)
	if err != nil {
		log.Fatalf("Error executing template: %v", err)
	}

	fmt.Printf("Successfully generated %s\n", outputFileName)
}
